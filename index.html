<!DOCTYPE html>
<html lang="en">
<head>
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="https://fonts.googleapis.com/css2?family=Sansita:ital,wght@1,700&display=swap" rel="stylesheet">
<title>WÃ˜RTLE</title>
<style>
  body {
    font-family: Trebuchet MS, Helvetica, Arial, sans-serif;
    text-align: center;
    background-color: #01222e;
    color: white;
    margin:0 auto;
  }

  #game {
    display: none;
    flex-direction: column;
    align-items: center;
    transition: opacity 0.5s ease-in-out;
    padding-bottom:50px;
  }
#game.dimmed {
    opacity: 0.5;
    pointer-events: none; /* Disables interaction with dimmed elements */
}
  .board {
    display: grid;
    grid-template-rows: repeat(6, 1fr);
    gap: 5px;
    margin: 20px;
  }
  .row {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 5px;
  }
  .tile {
    box-shadow: 2px 2px 2px #732b2b;
    width: 60px;
    height: 60px;
    border: 3px solid #041c47;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2em;
    font-weight: bold;
    text-transform: uppercase;
    background-color: #121213;
    color: white;
    border-radius:5px;
    transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
  }
  .correct { background-color: #538d4e !important; }
  .present { background-color: #b59f3b !important; }
  .absent { background-color: #3a3a3c !important; }
  .keyboard {
    display: flex;
    flex-direction: column;
    gap: 5px;
    max-width: 600px;
    margin-top:20px;
    margin-bottom:20px;
  }
  .key-row {
    display: flex;
    justify-content: center;
    gap: 5px;
  }
  .key {
    padding: 10px;
    background-color: #818384;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 1em;
    font-weight: bold;
    color: white;
    user-select: none;
  }
  #hintBtn1, #hintBtn2, #hintBtn3, #hintBtn4 {
    height: 68px;
    background: transparent;
    text-align: left;
    border: 0px;
    border-radius:5px;
    margin-bottom: 5px;
    cursor: pointer;
    padding: 0 0 0 10px;
    color: #214a5a;
    font-size: 10pt;
    align-items: center;
    justify-content: center;
    transition: color 0.3s ease;
  border-bottom: 2px solid #81a4c7;
  }
#hintTitle {
  width:200px;
  text-align: center; 
  text-transform: lowercase;
  margin:0 auto;
  font-weight: 700; 
  font-style:italic;
  font-family: 'Sansita', cursive;
  margin-bottom: 10px; 
  font-size: 1.3em; 
  letter-spacing: 2pt;
  position: relative; 
}
#hintTitle::before {
  content: ""; /* Required for pseudo-elements */
  position: absolute;
  background-color: #4f1868; /* Your desired "offset" color */
  width: 148px; /* Or specific width/height */
  height: 9px; /* Or specific width/height */
  top: 18px; /* Offset from the top */
  left: 25px; /* Offset from the left */
  z-index: -1; /* Place it behind the parent content */
}
#hintTitle:hover::before {
  background-color: #1e0729; /* Your desired "offset" color */
  transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
}
.hint-button {
  display: none;
}
#hintButtons button {
  width: 180px;
  align-items: flex-start;
  flex-direction: column;
  gap: 4px;
  padding: 5px 0;
  letter-spacing: 1pt;
  font-weight: bold;
  background: rgb(3, 39, 93);
  border: 2px solid rgb(14, 12, 43);
  border-left: 4px solid rgb(14, 12, 43);
  box-shadow: 0 0.2rem rgb(14, 12, 43);
  border-radius: 10px;
  margin: 4px 2px;
  cursor: pointer;
  color: #c7d1d5;
  font-size: 10pt;
  white-space: normal;
  overflow: hidden;
  height: auto;
  transition: background-color 0.3s ease;
}

  #hintButtons button.expanded {
  opacity: 1;
  max-height: 220px;
  }
  #hintButtons button:disabled {
  cursor: default;
  opacity: 1;
}
.hint-label {
    text-transform: lowercase;
    padding-bottom: 2px;
    font-size: 13pt;
    width: 100%;
    letter-spacing: 1pt;
    margin: 0;
    font-family: 'Sansita', cursive;
}
  
  .hint-label.hidden {
      margin-right: 10px;
  }

.hint-text {
  display: block;
  font-weight: normal;
  opacity: 0;
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.5s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.5s ease;
  width: 100%;
  box-sizing: border-box;
}

.hint-text.visible {
  opacity: 1;
  padding: 7px 15px 7px 7px;
  width: 500px;
  text-transform: uppercase;
  overflow: scroll;
  max-height: 68px;
  font-size: 11pt;
  text-align:right;
  font-family: Trebuchet MS, Helvetica, Arial, sans-serif;
}
#hintBtn1:hover, #hintBtn2:hover, #hintBtn3:hover, #hintBtn4:hover,
#hintBtn1.clicked-hint, #hintBtn2.clicked-hint, #hintBtn3.clicked-hint, #hintBtn4.clicked-hint {
  transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
  background-color: #b3c4e0;
  border-bottom: 2px solid #81a4c7;
}
.styled-button {
    background-color: transparent;
    border: none;
    width: auto;
    color: rgb(255, 255, 255);
    text-shadow: 2px 2px #000000;
    font-size: 0.9em;
    font-family: Trebuchet MS, Helvetica, Arial, sans-serif;
    cursor: pointer;
    margin: 5px auto;
}
  #modalCopyBtn, #showStatsBtn, #showScoreboardBtn, #copy-url-btn, #start-playing-btn {
    background-color: #e4e4e4;
    border: none;
    padding: 10px;
    font-weight: bold;
    font-size: 10pt;
    width: 10em;
    border-radius: 1rem;
    color: rgb(35, 35, 35);
    box-shadow: 0 0.4rem #1d1d1d;
    border: 2px solid #1d1d1d;
    cursor: pointer;
    margin: 5px auto;
  }
  #modalCopyBtn:hover, #showStatsBtn:hover, #showScoreboardBtn:hover, #copy-url-btn:hover, #start-playing-btn:hover {
    background-color: #e97251;
    color: #e9e9e9;
    transition: background-color 0.1s ease-in-out, color 0.1s ease-in-out;
  }
  #modal-stats-display {
    text-align: center;
  }
  h1 { 
    letter-spacing: 1pt; 
    border-bottom:1px solid rgb(34, 65, 78);
    padding:1.4rem;
    margin:0;
    background-color:rgb(3, 22, 27);
    font-family: monospace;
    position: relative;
    text-align: center;
  }
h1 p {
  margin: 0;
  }

.h1-button-group {
  position: absolute;
  top: 50%;
  right: 30px; /* Adjust spacing from the edge as needed */
  transform: translateY(-50%); /* Vertically center the buttons */
}
/* Styling for the simple share modal */
.share-popup {
  /* Use the classic centering method for this modal */
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 1001;
  width: 360px;
  
  /* Hiding and transition */
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease, visibility 0.3s ease;
}

/* Rule to show the share modal */
.share-popup.show {
  opacity: 1;
  visibility: visible;
}
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.6);
  z-index: 1000;

  /* Flexbox properties for centering */
  display: flex;
  align-items: center;     /* Vertical centering */
  justify-content: center; /* Horizontal centering */
  
  /* Hiding and transition */
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease, visibility 0.3s ease;
}
.modal {
  position: relative;
  width: 360px;
  
  /* The animation for the modal itself */
  transform: scale(0.95);
  opacity: 0;
  transition: opacity 0.3s ease, transform 0.3s ease;
  transition-delay: 0.1s; /* Small delay to let the overlay fade in first */
}



/* This class now controls the visibility of the overlay and the modal inside it */
.modal-overlay.show {
  opacity: 1;
  visibility: visible;
}
/* When the overlay is shown, also animate the modal */
.modal-overlay.show .modal {
  transform: scale(1);
  opacity: 1;
}
  #modal-message { font-size: 16pt; width:auto; font-family:monospace; }
  .modal-content {
    position: relative; 
  width:300px;
  max-height:80%;
  background-color: #e1dbd9;
  border-top:20px solid rgb(206, 86, 17);
  border-radius:10px;
  padding: 15px 30px 30px 30px;
  text-align: center;
  display: flex;
  flex-direction: column;
  gap: 15px;
  color: rgb(33, 33, 33);
  }
  #modal-summary {
    white-space: pre-wrap;
    font-family: monospace;
    font-size: 1.2em;
    color: rgb(33, 33, 33);
    letter-spacing: 2pt;
  }
  #hintButtonsContainer {
    display: flex;
    flex-direction: column;
    justify-content: center;
    gap: 3px;
    margin-top: 30px;
  }
  #secretWordColor {
  color: #cd1616; /* Example: a bright orange color */
}
.host-input {
  background: #021a24;
  font-size:11pt;
  color: #c7d1d5;
  border: none;
  padding: 8px;
  border-radius: 6px;
  width: 200px;
  display: block;
  margin: auto;
  margin-top: 5px;
  margin-bottom: 5px;
  text-align: center;
  transition: background 0.2s ease; /* Smooth color change */
}

.host-input::placeholder, #funFactInput::placeholder {
  color: #6f8a94;
}
.host-input:not(:placeholder-shown), #funFactInput:not(:placeholder-shown) {
  background: #010f15;
}
#hintInput4Container {
  margin: auto;
  margin-top: 5px;
  margin-bottom: 5px;
  display: block;
  background: #021a24;
  padding: 8px;
  width: 200px;
  border-radius: 6px;
  text-align:center;
  transition: background 0.2s ease; /* Smooth color change */
}

#hintInput4Container.darkened {
  background: #010f15;
}
#secretInput {
  text-transform: uppercase;
}

#modal-stats-container {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.5s ease-in-out, margin-top 0.5s ease-in-out;
    background-color: #d8d8d8;
    color: #333;
    padding: 0 10px;
    border-radius: 8px;
  }

  #modal-stats-container.expanded {
    max-height: 500px;
  }

  .stats-line {
    margin: 5px 0;
    font-family: monospace;
  }

  .button-group {
    display: inline-block;
    flex-direction: column;
    gap: 15px;
    width: 100%;
    align-items: center;
  }
  
  .key:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  #topStatsDisplay, #username-display-area {
    transition: opacity 0.2s;
    text-shadow:2px 2px #000000;
    font-size: 0.9em;
  }
    /* Add the keyframe animation */
  @keyframes shake {
    0%, 100% { transform: translateX(0); }
    20%, 60% { transform: translateX(-5px); }
    40%, 80% { transform: translateX(5px); }
  }

  /* Add the class to apply the animation */
  .shake {
    animation: shake 0.5s ease-in-out;
  }
  #funFactInput {
  background: #021a24;
  color: #c7d1d5;
  border: none;
  padding: 8px 28px;
  min-height: 70px;
  font-family:'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
  border-radius: 6px;
  font-size: 11pt;
  width: 300px;
  display: block;
  margin: auto;
  margin-top: 5px;
  margin-bottom: 5px;
  text-align: center;
  transition: background 0.2s ease;
  resize: vertical; /* Let users adjust height if they want */
  line-height: 1.4;
  }
  .fun-fact-section {
    background-color: #d8d8d8; /* A dark blue-gray background */
    color: #333; /* A light off-white font color */
    font-size: 11pt; /* Slightly larger font size */
    box-shadow: 0 0.4rem #5d849f;
    border:2px solid #5d849f;
    padding: 10px;
    border-radius: 8px;
    margin-top: 10px;
    min-height:60px;
    max-height:120px;
    overflow:scroll;
  }
  .fun-fact-section h2 {
    font-size:12pt;
    margin:4px 0 6px 0;
  }
  .fun-fact-section::-webkit-scrollbar {
  width: 10px; /* Width of the vertical scrollbar */
}
/* Scrollbar thumb */
.fun-fact-section::-webkit-scrollbar-thumb {
  background-color: #a14612; /* Color of the thumb */
  border-radius: 0px 6px; /* Rounded corners for the thumb */
}
/* Track */
.fun-fact-section::-webkit-scrollbar-corner {
  background: #4e1919;
  border-radius: 6px 0px;
}
.help-button {
  background: #07548a;
  color: white;
  border: none;
  border-radius: 50%;
  width: 29px;
  height: 29px;
  font-weight: bold;
  font-size: 18px;
  line-height: 1;
  cursor: pointer;
  vertical-align: middle;
  user-select: none;
  transition: background-color 0.3s ease;
}

.help-button:hover {
  background-color: #0a73c2;
}
.help-popup {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #e1dbd9;
  color: #212121;
  max-width: 360px;
  border-radius: 10px;
  box-shadow: 0 0 15px rgba(0,0,0,0.5);
  z-index: 9999;
  display: flex; /* Use flex by default */
  flex-direction: column;
  outline: 2px solid orange;
  padding: 2px 6px;
}/* Hide when hidden attribute is present */
.help-popup[hidden] {
  display: none;
}
.help-popup:focus {
  outline: 2px solid orange;
}
.help-popup-content {
  position: relative;
  padding: 20px 45px;
    overflow: scroll;
    max-height: 550px;
}
.close-help-btn, .close-hint-btn, .close-btn {
  position: absolute;
  top: 0px;
  right: 2px;
  border: none;
  background: transparent;
  font-size: 30px;
  line-height: 1;
  cursor: pointer;
  color: #333;
  font-family:'Sansita', cursive;
  font-weight: bold;
}
.close-help-btn:hover, .close-hint-btn:hover, .close-btn:hover {
  transition: background-color 0.3s ease;
  color: #000;
}
.help-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0,0,0,0.4); /* dim background */
  z-index: 9998; /* just below the popup */
}
/* The dark background overlay */
#hintPopupOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  /* This z-index is crucial. It must be high. */
  z-index: 999;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease, visibility 0s 0.3s;
}

/* The popup box itself */
.hint-popup {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  max-width: 400px;
  margin: 0 auto;
  padding: 10px;
  background-color: #d0d9dc;
  border-radius: 10px;
  border: 2px solid #b3c4e0;
  /* This must have a HIGHER z-index than the overlay. */
  z-index: 1000;
  transform: translateY(100%);
  opacity: 0;
  visibility: hidden;
  transition: transform 0.3s ease, opacity 0.3s ease, visibility 0s 0.3s;
}

/* --- The rest of the CSS remains the same --- */

/* Active (visible) state for the popup */
.hint-popup.show {
  transform: translateY(0);
  opacity: 1;
  visibility: visible;
  transition-delay: 0s;
}

/* When the popup is shown, also show the overlay */
.hint-popup.show + #hintPopupOverlay {
  opacity: 1;
  visibility: visible;
  transition-delay: 0s;
}
#share-message-box {
    width: 100%;
    height: 80px;
    padding: 10px;
    box-sizing: border-box;
    background-color: #d8d8d8;
    border: 2px dashed #ccc;
    border-radius: 15px;
    color: #4b819d;
    font-family: 'Trebuchet MS', Helvetica, Arial, sans-serif;
    font-size: 1em;
    resize: none;
}
#share-message-box:focus {
    outline: none;
}
/* Container for the custom tooltip */
.custom-tooltip {
  position: relative; /* This is required for positioning the tooltip */
  cursor: pointer;
}
/* The tooltip itself, created with a pseudo-element */
.custom-tooltip::after {
  content: attr(data-tooltip); /* Grabs the text from the data-tooltip attribute */
  position: absolute;
  top: 100%; /* Position it above the button */
  left: 50%;
  transform: translateX(-50%);
  margin-top: 10px; /* Space between button and tooltip */
  /* Appearance */
  background-color: #d8d8d8;
  color: #4b819d;
  font-weight:400;
  padding: 8px;
  border-radius: 4px;
  font-family:'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
  font-size: 14px;
  white-space: nowrap; /* Prevent the text from wrapping */
  /* Visibility and instant transition */
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.1s ease, visibility 0.1s ease;
  transition-delay: 0s; /* No delay on hiding */
}

/* Show the tooltip on hover */
.custom-tooltip:hover::after {
  opacity: 1;
  visibility: visible;
  transition-delay: 0s; /* No delay on showing */
}

table {
  font-family: monospace;
  font-size:10pt;
  border-collapse: collapse;
  width: 100%;
  border-collapse: separate;
  border-spacing: 0;
}
tr>:nth-child(2){
  min-width: 35px;
}
tr>:nth-child(1), tr>:nth-child(4) {
  max-width:20px;
  text-align:center;
}
tr>:nth-child(3) {
  max-width:30px;
  text-align:center;
}
td, th {
  border: 1px #ddd;
  border-style: none solid solid none;
  padding: 5px;
  text-align:left;
}
td {
  max-width: 10px;
  overflow: scroll;
}
th {
  border:0px;
}
tr:first-child td:first-child { border-top-left-radius: 10px; }
tr:first-child td:last-child { border-top-right-radius: 10px; }

tr:last-child td:first-child { border-bottom-left-radius: 10px; }
tr:last-child td:last-child { border-bottom-right-radius: 10px; }

tr:first-child td { border-top-style: solid; }
tr td:first-child { border-left-style: solid; }
tr:nth-child(even){
  background-color: #01222e;
}
#game-over-modal {
  position: relative; /* Establishes a stacking context */ /* Acts as the positioning anchor */
}
.side-panel {
  position: absolute;
  top: 25px;
  left: 360px;
  z-index: 1;
  /* --- MODIFIED --- */
  width: 0;
  overflow: hidden; /* This now hides the static inner content */
  transition: width 0.4s ease-in-out;
  padding: 0; /* Padding is now on the inner wrapper */
  /* Your other styles */
  height: 90%;
  background-color: #021a24;
  color: #fff;
  border-radius: 0 12px 12px 0;
  box-shadow: 5px 0 15px rgba(0, 0, 0, 0.2);
  pointer-events: none;
}
.side-panel.show {
  width: 280px; /* The outer container still expands to this width */
  pointer-events: auto;
}
/* --- ADD THIS NEW RULE --- */
.side-panel-content {
  /* This container has a fixed width, so the text inside doesn't reflow */
  width: 280px;
  padding: 20px;
  height: 100%;
  overflow: auto; /* Adds a scrollbar if content is too tall */
  box-sizing: border-box; /* Keeps padding inside the defined width/height */
}
.close-btn {
  color:#384d58;
}
    /* Add these new styles for the scoreboard summary */
    #scoreboard-summary-container {
        padding: 10px 15px;
        border-bottom: 1px solid #444; /* A separator line */
        margin-bottom: 10px;
    }

    .summary-stat {
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 14px;
    }

    .summary-stat:last-child {
        margin-bottom: 0;
    }

    .stat-label {
        width: 90px; /* Helps align the labels */
        text-align: left;
        color: #c7d1d5;
        flex-shrink: 0;
    }

    .stat-bar-container {
        flex-grow: 1;
        height: 20px;
        border-right: 3px dotted #384d58;
        overflow: hidden;
    }

    .stat-bar {
        height: 100%;
        background-color: rgb(92, 17, 17); /* A color that fits your theme */
        border-radius: 5px;
        transition: width 0.5s ease-in-out;
        text-align: center;
    text-shadow: 1px 2px #000000;
    color: #e5e8ea;
        font-weight: bold;
        line-height: 20px; /* Vertically center text */
        white-space: nowrap;
    }


</style>
</head>
<body>

<div id="mainContent">
<h1>
  <p><span style="color:rgb(243, 202, 186);">Cross-Germanic</span> WÃ˜RTLE</p>
  <div class="h1-button-group">
    <button id="newGameBtn" aria-label="Create new game" class="help-button custom-tooltip" data-tooltip="New WÃ¸rtle">+</button>
   <button id="helpBtn" aria-label="Show help" data-tooltip="Info" class="help-button custom-tooltip">?</button>
  </div>
</h1>
<div id="header-info" style="height:35px;display: flex; justify-content: space-between; align-items: center; max-width: 750px; margin: 10px auto; padding: 0 10px;">
<div id="username-display-area" style="display:flex; flex-direction:column; justify-content:center; align-items:center; text-align: left; width:180px;">
  </div>
  <div id="topStatsDisplay" style="padding:0 5px;">
    </div>
  <div id="change-user-button-area" style="text-align: center; width:180px;">
    </div>
</div>
<div id="setup" style="padding-bottom:50px;">
  <p style="margin-bottom:20px;">Host: Enter a secret word and optional hints for the user to reveal</p>
  <input type="text" id="secretInput" maxlength="5" placeholder="Secret word" style="border:2px solid rgb(92, 17, 17);" class="host-input"/>
    <button id="generateWordBtn" style="margin:5px 0 7px 0;">Pick Random Word</button>
  <input type="text" id="hintInput" placeholder="Language" class="host-input"/>
  <input type="text" id="hintInput2" placeholder="Part of speech" class="host-input"/>
  <input type="text" id="hintInput3" placeholder="Context clue" class="host-input"/>
<div id="hintInput4Container">
  <p style="margin:0 0 5px 0; font-size:11pt; color:#c7d1d5;">Special character(s)</p>
  <label style="display:block; margin-bottom:4px; cursor:pointer;">
    <input type="checkbox" value="Ã„" class="specialCharCheckbox"> Ã„
  </label>
  <label style="display:block; margin-bottom:4px; cursor:pointer;">
    <input type="checkbox" value="Ã–" class="specialCharCheckbox"> Ã–
  </label>
  <label style="display:block; margin-bottom:4px; cursor:pointer;">
    <input type="checkbox" value="Ãœ" class="specialCharCheckbox"> Ãœ
  </label>
  <label style="display:block; margin-bottom:4px; cursor:pointer;">
    <input type="checkbox" value="áºž" class="specialCharCheckbox"> áºž
  </label>
  <label style="display:block; margin-bottom:4px; cursor:pointer;">
    <input type="checkbox" value="Ã†" class="specialCharCheckbox"> Ã†
  </label>
  <label style="display:block; margin-bottom:4px; cursor:pointer;">
    <input type="checkbox" value="Ã˜" class="specialCharCheckbox"> Ã˜
  </label>
  <label style="display:block; margin-bottom:4px; cursor:pointer;">
    <input type="checkbox" value="Ã…" class="specialCharCheckbox"> Ã…
  </label>
</div>
  <textarea id="funFactInput" placeholder="Fun fact about the word (to be shown after the game is over)"></textarea>
  <button onclick="startGame()" style="margin:10px;">Create Game</button>
</div>

<div id="game">
  <p id="message"></p>
  <button id="copyBtn" style="display:none; margin:5px;" onclick="copyResult()">Copy Result</button>
  <div id="board" class="board"></div>

<div id="hintButtons" style="display: none;">
  <div id="hintTitle" style="cursor:pointer;">Need a hint?</div>
</div>

  <div id="keyboard" class="keyboard"></div>
</div>

<div id="game-over-overlay" class="modal-overlay">

  <div id="game-over-modal" class="modal">

    <div id="scoreboard-panel" class="side-panel">
      <div class="side-panel-content">
        <h2 style="font-size:14pt;">Scoreboard for <span id="scoreboard-word"></span></h2>
        <div id="scoreboard-summary-container"></div>
        <div id="scoreboard-container"></div>
      </div>
    </div>

    <div class="modal-content">
      <p id="modal-message"></p>
      <pre id="modal-summary"></pre>

      <div class="modal-button-container">
        <button id="modalCopyBtn">Copy Result</button>
        <button id="showStatsBtn">Show My Stats</button>
        <div id="modal-stats-container"></div>
        <button id="showScoreboardBtn">View Scoreboard</button>
      </div>
    </div>

  </div>
</div>

<div id="share-modal" class="share-popup">
  <div class="modal-content">
    <p style="font-weight:600;margin-bottom:5px;font-size: 12pt;width:auto;font-family:monospace;">Share with others:</p>
    <textarea id="share-message-box" readonly></textarea>
    <div class="button-group">
      <button id="copy-url-btn">Copy Text</button>
      <button id="start-playing-btn">Start Playing</button>
    </div>
  </div>
</div>
</div>

<div id="helpOverlay" class="help-overlay" hidden></div>
<div id="helpPopup" class="help-popup" role="dialog" aria-modal="true" aria-labelledby="helpTitle" tabindex="-1" hidden>
  <div class="help-popup-content">
    <button id="closeHelpBtn" aria-label="Close help" class="close-help-btn">&times;</button>
    <h2 id="helpTitle">How to play</h2>
    <p><b>Host:</b> Enter or generate a secret word, as well as any optional hints for the user to reveal. Then share the URL.</p>
    <p><b>Players:</b> Guess the secret word by entering guesses. Use hints if needed. Good luck!</p>
    <p>--------------------</p>
    <p>WÃ˜RTLE is currently enabled for:<br>de, no, sv, da & en</p>
    <p>Note that each language utilises a limited word list, which vary quite a bit in how extensive they are.</p>
    <p><i>Created by lokke@ and bicks@<br>Original idea by aottl@</i></p>
    <p>--------------------</p>
    <p>Find a bug? Want to add a word to the word list? Or have any other suggestions for improvement?<br>Please write to lokke@google.com</p>
  </div>
</div>

<div id="hintPopup" class="hint-popup" role="dialog" aria-modal="true" aria-labelledby="hintPopupTitle">
    <button id="closeHintPopupBtn" aria-label="Close hint popup" class="close-hint-btn">&times;</button>
    <div id="hintButtonsContainer">
        <button id="hintBtn1" class="hint-button" onclick="showHint(1)">
            <span class="hint-label">Language</span>
            <span class="hint-text"></span>
        </button>
        <button id="hintBtn2" class="hint-button" onclick="showHint(2)">
            <span class="hint-label">Part Of Speech</span>
            <span class="hint-text"></span>
        </button>
        <button id="hintBtn3" class="hint-button" onclick="showHint(3)">
            <span class="hint-label">Context</span>
            <span class="hint-text"></span>
        </button>
        <button id="hintBtn4" class="hint-button" onclick="showHint(4)">
            <span class="hint-label">Special Character(s)</span>
            <span class="hint-text"></span>
        </button>
    </div>
</div>

<div id="hintPopupOverlay" class="popup-overlay"></div>

<script>
let secret = "";
let customHint1 = "";
let customHint2 = "";
let customHint3 = "";
let customHint4 = "";
let customFunFact = "";
let hintUsed1 = false;
let hintUsed2 = false;
let hintUsed3 = false;
let hintUsed4 = false;
let currentRow = 0;
let currentCol = 0;
const rows = 6;
const cols = 5;
let grid = [];
let keyColors = {};
let guessHistory = [];
let colorHistory = [];
let usernameSet = false;
let isAnimating = false;
let gameCreatedDate = null;
let hintExpanded1 = false;
let hintExpanded2 = false;
let hintExpanded3 = false;
let hintExpanded4 = false;
let scoreboardListener = null;
const hintTitle = document.getElementById("hintTitle");
const hintPopup = document.getElementById("hintPopup");
const hintPopupOverlay = document.getElementById("hintPopupOverlay");
const closeHintPopupBtn = document.getElementById("closeHintPopupBtn");
const game = document.getElementById("game");
const SUPPORTED_LANGUAGES = ['german', 'norwegian', 'english', 'swedish', 'danish']; // <-- Add all your file names here (without .txt)
const allValidWords = new Set();


// Add this corrected block to the top of your script

// Your web app's Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyDGepZP9hu3hHAL1wfrp4gjIurEPLPUbaw",
  authDomain: "woertle-7dc73.firebaseapp.com",
  databaseURL: "https://woertle-7dc73-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "woertle-7dc73",
  storageBucket: "woertle-7dc73.firebasestorage.app",
  messagingSenderId: "97063588719",
  appId: "1:97063588719:web:dc734f9c0772d49e5b0e9a"
};

// Initialize Firebase using the global firebase object
firebase.initializeApp(firebaseConfig);

// Create a database reference for your other functions to use
const database = firebase.database();

(async () => {
  await loadAllWordLists();
  // You can enable the "Create Game" button here after lists are loaded
})();

// Base64 helpers
function base64Encode(str) { return btoa(unescape(encodeURIComponent(str))); }
function base64Decode(str) { try { return decodeURIComponent(escape(atob(str))); } catch { return null; } }

function getSecretFromURL() {
  const params = new URLSearchParams(window.location.search);
  const encodedWord = params.get("w");
  const encodedHint1 = params.get("h1");
  const encodedHint2 = params.get("h2");
  const encodedHint3 = params.get("h3");
  const encodedHint4 = params.get("h4");

  if (!encodedWord) return null;
  const decodedWord = base64Decode(encodedWord);

  customHint1 = encodedHint1 ? base64Decode(encodedHint1) : "";
  customHint2 = encodedHint2 ? base64Decode(encodedHint2) : "";
  customHint3 = encodedHint3 ? base64Decode(encodedHint3) : "";
  customHint4 = encodedHint4 ? base64Decode(encodedHint4) : "";

  const encodedFunFact = params.get("ff");
  customFunFact = encodedFunFact ? base64Decode(encodedFunFact) : "";

  // âœ… Parse and store creation date ONLY if not already set
  if (!gameCreatedDate) {
    const encodedDate = params.get("d");
    if (encodedDate) {
      const decodedDateStr = base64Decode(encodedDate);
      const parsedDate = new Date(decodedDateStr);
      if (!isNaN(parsedDate)) {
        gameCreatedDate = parsedDate;
      }
    }
  }

  if (decodedWord && /^[A-ZÃ†Ã˜Ã…Ã„Ã–Ãœáºž]{5}$/.test(decodedWord)) {
    return decodedWord.toUpperCase();
  }
  return null;
}

const hintContainer = document.getElementById("hintInput4Container");
const specialCharBoxes = document.querySelectorAll(".specialCharCheckbox");

function updateHintContainerBackground() {
  const anyChecked = Array.from(specialCharBoxes).some(cb => cb.checked);
  hintContainer.classList.toggle("darkened", anyChecked);
}

specialCharBoxes.forEach(cb => {
  cb.addEventListener("change", updateHintContainerBackground);
});

function saveSetupState() {
  const setupState = {
    secret: document.getElementById('secretInput').value,
    hint1: document.getElementById('hintInput').value,
    hint2: document.getElementById('hintInput2').value,
    hint3: document.getElementById('hintInput3').value,
    funFact: document.getElementById('funFactInput').value,
    // Save an array of the values of all checked boxes
    specialChars: Array.from(document.querySelectorAll('.specialCharCheckbox:checked')).map(cb => cb.value)
  };
  // Convert the object to a string and save it
  localStorage.setItem('wurtleSetupState', JSON.stringify(setupState));
}

function loadSetupState() {
  const savedStateJSON = localStorage.getItem('wurtleSetupState');
  if (savedStateJSON) {
    const savedState = JSON.parse(savedStateJSON);
    
    // Repopulate all the text fields
    document.getElementById('secretInput').value = savedState.secret || '';
    document.getElementById('hintInput').value = savedState.hint1 || '';
    document.getElementById('hintInput2').value = savedState.hint2 || '';
    document.getElementById('hintInput3').value = savedState.hint3 || '';
    document.getElementById('funFactInput').value = savedState.funFact || '';

    // Re-check all the necessary checkboxes
    if (savedState.specialChars && savedState.specialChars.length > 0) {
      document.querySelectorAll('.specialCharCheckbox').forEach(cb => {
        if (savedState.specialChars.includes(cb.value)) {
          cb.checked = true;
        }
      });
    }
  }
}

function generateShareURL(word, hint1, hint2, hint3, hint4, funFact) {
  const url = new URL(window.location);
  url.searchParams.set("w", base64Encode(word));
  if (hint1) url.searchParams.set("h1", base64Encode(hint1));
  if (hint2) url.searchParams.set("h2", base64Encode(hint2));
  if (hint3) url.searchParams.set("h3", base64Encode(hint3));
  if (hint4) url.searchParams.set("h4", base64Encode(hint4));
  if (funFact) url.searchParams.set("ff", base64Encode(funFact));
  const today = new Date().toISOString();
  url.searchParams.set("d", base64Encode(today));
  return url.href;
}

function getStats(username) {
  const stats = JSON.parse(localStorage.getItem("gerNordleStats") || "{}");
  return stats[username] || { gamesPlayed: 0, wins: 0, totalGuesses: 0 };
}

function saveStats(username, stats) {
  const allStats = JSON.parse(localStorage.getItem("gerNordleStats") || "{}");
  allStats[username] = stats;
  localStorage.setItem("gerNordleStats", JSON.stringify(allStats));
}

function updateStats(username, won, guesses) {
  const user = username || "Player";
  const stats = getStats(user);
  stats.gamesPlayed++;
  if (won) {
    stats.wins++;
    stats.totalGuesses += guesses;
  }
  saveStats(user, stats);
}

function displayStats(username) {
  const user = username || "Player";
  const stats = getStats(user);
  let avgGuesses = stats.wins > 0 ? (stats.totalGuesses / stats.wins).toFixed(2) : "-";
  let winPct = stats.gamesPlayed > 0 ? ((stats.wins / stats.gamesPlayed) * 100).toFixed(1) : "0.0";
  
  return [
    `Stats for ${user}`,
    `Games Played: ${stats.gamesPlayed}`,
    `Wins: ${stats.wins}`,
    `Win %: ${winPct}%`,
    `Average Guesses: ${avgGuesses}`
  ];
}

async function startGame() {
  const inputWord = document.getElementById("secretInput").value.trim().toUpperCase();
  const inputHint1 = document.getElementById("hintInput").value.trim();
  const inputHint2 = document.getElementById("hintInput2").value.trim();
  const inputHint3 = document.getElementById("hintInput3").value.trim();
  const inputHint4 = Array.from(document.querySelectorAll(".specialCharCheckbox:checked"))
                        .map(cb => cb.value)
                        .join(", ");
  const inputFunFact = document.getElementById("funFactInput").value.trim();

  // Validate the user input for the secret word
  if (!inputWord) {
    alert("Please enter a secret word.");
    return;
  }

  if (inputWord.length !== 5 || !/^[A-ZÃ„Ã–ÃœÃŸáºžÃ†Ã˜Ã…]+$/i.test(inputWord)) {
    alert("Secret word must be exactly 5 letters and can include Ã„, Ã–, Ãœ, ÃŸ, áºž, Ã†, Ã˜, Ã….");
    return;
  }

  if (!allValidWords.has(inputWord.toLowerCase())) {
    alert(`The word "${inputWord}" is not in the valid word dictionary. Please choose another word.`);
    return;
  }

  // --- NEW: Check if the game already exists in Firebase ---
  try {
    const gameRef = database.ref('games/' + inputWord);
    const snapshot = await gameRef.once('value');

    if (snapshot.exists()) {
      // If data exists at this path, the game has already been made.
      alert(`A WÃ¸rtle for the word "${inputWord}" has already been created. Please choose a different word.`);
      return; // Stop the function from proceeding.
    }
  } catch (error) {
    console.error("Firebase check failed:", error);
    alert("Could not check if game exists. Please try again.");
    return;
  }

  // If all checks have passed, clear the saved setup data from localStorage.
  localStorage.removeItem('wurtleSetupState');

  // --- END OF NEW CODE ---

  // Set the global variables
  secret = inputWord;
  customHint1 = inputHint1;
  customHint2 = inputHint2;
  customHint3 = inputHint3;
  customHint4 = inputHint4;
  customFunFact = inputFunFact;

  // Generate the original long URL needed for the game to function
  const longUrl = generateShareURL(secret, customHint1, customHint2, customHint3, customHint4, customFunFact);

  // Get modal elements
  const shareModal = document.getElementById("share-modal");
  const shareMessageBox = document.getElementById("share-message-box");
  const copyBtn = document.getElementById("copy-url-btn");
  const startBtn = document.getElementById("start-playing-btn");
  const modalMessage = shareModal.querySelector('p');

  // Show the modal immediately with a loading state
  modalMessage.textContent = "Share with others:";
  shareMessageBox.value = "Creating short link...";
  copyBtn.disabled = true;
  startBtn.disabled = true;
  shareModal.classList.add("show");

  try {
    // Call the TinyURL API to shorten the link
    const response = await fetch(`https://tinyurl.com/api-create.php?url=${encodeURIComponent(longUrl)}`);
    if (!response.ok) {
      throw new Error('TinyURL service is not available.');
    }
    const shortUrl = await response.text();
    // Construct the full message with the short URL
    shareMessageBox.value = `Hi! Play my WÃ˜RTLE: ${shortUrl}`;
  } catch (error) {
    console.error("Could not shorten URL:", error);
    modalMessage.innerHTML = "Could not create short link.<br>Please share the full link below:";
    // Construct the full message with the long URL as a fallback
    shareMessageBox.value = `Hi! Play my WÃ˜RTLE: ${longUrl}`;
  } finally {
    // Re-enable the buttons once the process is complete
    copyBtn.disabled = false;
    startBtn.disabled = false;
  }

  // Handle Copy Button click
  copyBtn.onclick = () => {
      shareMessageBox.select();
      shareMessageBox.setSelectionRange(0, 99999);
      navigator.clipboard.writeText(shareMessageBox.value).then(() => {
          copyBtn.textContent = "Copied!";
          setTimeout(() => { copyBtn.textContent = "Copy Text"; }, 2000);
      }).catch(err => {
          console.error('Failed to copy message: ', err);
          alert('Could not copy message automatically. Please copy it manually.');
      });
  };

  // Handle Start Playing Button click
  startBtn.onclick = () => {
      shareModal.classList.remove("show");
      window.history.replaceState({}, "", longUrl);
      document.getElementById("header-info").style.display = "flex";
      document.getElementById("setup").style.display = "none";
      document.getElementById("game").style.display = "flex";
      checkUserStatus();
  };
}

function checkUserStatus() {
    const savedUsername = localStorage.getItem("gerNordleUsername");
    const gameElement = document.getElementById("game");

    // Clear all header areas at the start
    document.getElementById("username-display-area").innerHTML = '';
    document.getElementById("topStatsDisplay").innerHTML = '';
    document.getElementById("change-user-button-area").innerHTML = '';

    const allGameData = JSON.parse(localStorage.getItem("gerNordleGameData") || "{}");
    const encodedSecret = secret ? base64Encode(secret) : null;
    const userGameHistory = savedUsername ? allGameData[savedUsername] : undefined;
    const pastGame = userGameHistory && encodedSecret ? userGameHistory[encodedSecret] : null;

    // 1. Check for a COMPLETED game first.
    if (pastGame && (pastGame.status === 'won' || pastGame.status === 'lost')) {
        setupHeader(savedUsername);
        gameElement.classList.add("dimmed");

        if (pastGame.createdDate) {
            gameCreatedDate = new Date(pastGame.createdDate);
        } else {
            gameCreatedDate = gameCreatedDate || new Date();
        }

        const isSolved = pastGame.status === 'won';
        document.getElementById("message").textContent = isSolved
            ? "You already solved this Wordle! ðŸ¥³"
            : "You have already played this Wordle.";

        const savedGuessHistory = pastGame.guessHistory;
        const savedColorHistory = pastGame.colorHistory;
        
        const savedHintStatus = pastGame.hintStatus;
        if (savedHintStatus) {
            hintUsed1 = savedHintStatus.hintUsed1;
            hintUsed2 = savedHintStatus.hintUsed2;
            hintUsed3 = savedHintStatus.hintUsed3;
            hintUsed4 = savedHintStatus.hintUsed4;
            hintExpanded1 = savedHintStatus.hintExpanded1 || false;
            hintExpanded2 = savedHintStatus.hintExpanded2 || false;
            hintExpanded3 = savedHintStatus.hintExpanded3 || false;
            hintExpanded4 = savedHintStatus.hintExpanded4 || false;
        }

        updateHintButtons();

        const modal = document.getElementById("game-over-modal");

        if (isSolved) {
            document.getElementById("modal-message").innerHTML =
                `You win! ðŸŽ‰<br>The secret word was <span id="secretWordColor">${secret}</span>.`;
        } else {
            document.getElementById("modal-message").innerHTML =
                `Game over!<br>The secret word was <span id="secretWordColor">${secret}</span>.`;
        }
        
        document.getElementById("modal-summary").textContent =
            generateResultText(true, savedGuessHistory, savedColorHistory, isSolved, savedHintStatus);

        const existingFunFact = document.querySelector("#game-over-modal .fun-fact-section");
        if (existingFunFact) existingFunFact.remove();

        if (customFunFact && customFunFact.trim() !== "") {
            const funFactDiv = document.createElement('div');
            funFactDiv.classList.add('fun-fact-section');
            const funFactHeader = document.createElement('h2');
            funFactHeader.textContent = "Fun fact about today's WÃ¸rtle:";
            const funFactText = document.createElement('p');
            funFactText.textContent = customFunFact;
            funFactText.style.margin = "0";
            funFactDiv.appendChild(funFactHeader);
            funFactDiv.appendChild(funFactText);
            const modalContent = document.querySelector("#game-over-modal .modal-content");
            if (modalContent) {
                modalContent.appendChild(funFactDiv);
            }
        }

        document.getElementById("modalCopyBtn").style.display = "block";

        // Populate stats before binding buttons
        const statsContainer = document.getElementById("modal-stats-container");
        statsContainer.innerHTML = "";
        displayStats(savedUsername).forEach(line => {
            const p = document.createElement("p");
            p.textContent = line;
            p.classList.add("stats-line");
            statsContainer.appendChild(p);
        });

        // Bind the modal buttons (Copy Result + Show My Stats)
        bindModalButtons(savedGuessHistory, savedColorHistory, isSolved, savedHintStatus);
        
        const headerInfo = document.getElementById("header-info");
          if (headerInfo) {
              headerInfo.style.visibility = "hidden";
          }

        document.querySelectorAll(".hint-button").forEach(btn => {
            btn.style.visibility = "hidden";
        });
                // Hide the game board to remove the scroll space
        document.getElementById("game").style.display = "none";
        document.getElementById("header-info").style.display = "none";
        document.getElementById("game-over-overlay").classList.add('show');

        return;
    } 
    // 2. ELSE, check for an ONGOING game.
    else if (pastGame && pastGame.ongoingState) {
        console.log("Found ongoing game, restoring state...");
        
        const savedState = pastGame.ongoingState;
        grid = savedState.grid;
        currentRow = savedState.currentRow;
        guessHistory = savedState.guessHistory;
        colorHistory = savedState.colorHistory;
        keyColors = savedState.keyColors;
        hintUsed1 = savedState.hintStatus.hintUsed1;
        hintUsed2 = savedState.hintStatus.hintUsed2;
        hintUsed3 = savedState.hintStatus.hintUsed3;
        hintUsed4 = savedState.hintStatus.hintUsed4;
        hintExpanded1 = savedState.hintStatus.hintExpanded1 || false;
        hintExpanded2 = savedState.hintStatus.hintExpanded2 || false;
        hintExpanded3 = savedState.hintStatus.hintExpanded3 || false;
        hintExpanded4 = savedState.hintStatus.hintExpanded4 || false;
        currentCol = 0;

        setupHeader(savedUsername);
        initKeyboard();
        initBoard();
        updateBoard();
        updateKeyboardColors();

        for (let r = 0; r < colorHistory.length; r++) {
            const colors = colorHistory[r];
            const rowDiv = document.getElementById("board").children[r];
            for (let c = 0; c < cols; c++) {
                if (rowDiv && rowDiv.children[c]) {
                    rowDiv.children[c].classList.add(colors[c]);
                }
            }
        }
        updateKeyboardColors();
        updateHintButtons();

        window.currentUsername = savedUsername;
        usernameSet = true;
        gameElement.classList.remove("dimmed");
        return;
    }

    // 3. If neither of the above, proceed as a NEW game.
    if (savedUsername) {
        setupHeader(savedUsername);
        gameElement.classList.remove("dimmed");
        window.currentUsername = savedUsername;
        usernameSet = true;

        resetHints();
        grid = Array(rows).fill(null).map(() => Array(cols).fill(""));
        guessHistory = [];
        colorHistory = [];
        keyColors = {};
        currentRow = 0;
        currentCol = 0;
        isAnimating = false;
        initBoard();
        initKeyboard();
        updateHintButtons();
        
        const displayMessage = document.createElement("p");
        displayMessage.textContent = `Playing as: ${savedUsername.toUpperCase()}`;
        displayMessage.style.cssText = "margin: 0;";
        usernameDisplayArea.appendChild(displayMessage);

        const changeButton = document.createElement("button");
        changeButton.textContent = "Change User";
        changeButton.onclick = promptForUsername;
        changeButton.classList.add("styled-button");
        changeUserButtonArea.appendChild(changeButton);

        const stats = getStats(savedUsername);
        let avgGuesses = stats.wins > 0 ? (stats.totalGuesses / stats.wins).toFixed(2) : "-";
        let winPct = stats.gamesPlayed > 0 ? ((stats.wins / stats.gamesPlayed) * 100).toFixed(1) : "0.0";

        topStatsDisplay.innerHTML = `Games Played: ${stats.gamesPlayed} | Win %: ${winPct}% | Avg. Guesses: ${avgGuesses}`;
        topStatsDisplay.style.display = "block";

        gameElement.classList.remove("dimmed");
    } else {
        initBoard();
        initKeyboard();
        updateHintButtons();
        promptForUsername();
        gameElement.classList.add("dimmed");
    }
}


function promptForUsername() {
  const usernameDisplayArea = document.getElementById("username-display-area");
  const topStatsDisplay = document.getElementById("topStatsDisplay");
  const changeUserButtonArea = document.getElementById("change-user-button-area");

  usernameDisplayArea.innerHTML = '';
  topStatsDisplay.innerHTML = '';
  changeUserButtonArea.innerHTML = '';

  const usernameInput = document.createElement("input");
  usernameInput.type = "text";
  usernameInput.id = "usernameInputGame";
  usernameInput.placeholder = "Enter username";
  usernameInput.style.cssText = "padding: 6px; border-radius: 6px; width: 180px;";

  const setButton = document.createElement("button");
  setButton.textContent = "Set Username";
  setButton.onclick = setUsername;
  setButton.classList.add("styled-button");

  topStatsDisplay.style.display = "flex";
  topStatsDisplay.style.gap = "8px";
  topStatsDisplay.style.justifyContent = "center";
  topStatsDisplay.style.alignItems = "center";

  topStatsDisplay.appendChild(usernameInput);
  topStatsDisplay.appendChild(setButton);

  window.currentUsername = null;
  usernameSet = false;
  document.getElementById("topStatsDisplay").style.display = "flex";
}

// NEW: Helper function to check if a username is already used for the current game by another player.
async function isUsernameTaken(usernameToCheck) {
  // We need the secret word to know which game to check.
  if (!secret) return false;

  const gameRef = database.ref('games/' + secret);
  const snapshot = await gameRef.once('value');
  const scores = snapshot.val();

  // If there are no scores for this game yet, the name is available.
  if (!scores) {
    return false;
  }

  const currentPlayerId = getPlayerId();
  const usernameToCheckUpper = usernameToCheck.toUpperCase();

  // The 'scores' object has keys like 'ENCODED_USERNAME_player_randomid123'
  for (const compositeKey in scores) {
    // ---- THIS IS THE CORRECTED LOGIC ----
    const playerMarker = '_player_';
    const markerIndex = compositeKey.indexOf(playerMarker);

    // If the key doesn't match our expected format (e.g. USERNAME_player_...), skip it.
    // markerIndex <= 0 means the username part would be empty.
    if (markerIndex <= 0) {
      continue;
    }

    const encodedUsername = compositeKey.substring(0, markerIndex);
    const keyPlayerId = compositeKey.substring(markerIndex + 1); // This gets the full 'player_...' string
    // ---- END OF CORRECTION ----
    
    try {
      const existingUsername = decodeURIComponent(encodedUsername);

      // Check if the username matches AND it belongs to a different player.
      if (existingUsername.toUpperCase() === usernameToCheckUpper && keyPlayerId !== currentPlayerId) {
        return true; // The username is taken by someone else.
      }
    } catch (e) {
      // This might happen with legacy or malformed data. It's safe to ignore and continue.
      console.error("Could not decode username from Firebase key:", encodedUsername, e);
      continue;
    }
  }

  return false; // The username is not taken by another player.
}
// MODIFIED: This function now checks Firebase before setting a username.
async function setUsername() {
  const usernameInput = document.getElementById("usernameInputGame");
  let username = usernameInput.value.trim();

  if (!username) {
    alert("Please enter a username.");
    return;
  }

  // Disable the button to prevent multiple clicks while checking
  const setButton = usernameInput.nextElementSibling;
  if (setButton) setButton.disabled = true;

  const isTaken = await isUsernameTaken(username);

  if (isTaken) {
    alert(`The username "${username.toUpperCase()}" is already in use for this WÃ¸rtle. Please choose another.`);
    if (setButton) setButton.disabled = false; // Re-enable the button
    return;
  }

  // If the username is available, proceed as before.
  username = username.toUpperCase();
  localStorage.setItem("gerNordleUsername", username);
  resetHints();
  checkUserStatus();
  // The UI will be rebuilt by checkUserStatus, so no need to re-enable the button here.
}


function updateBoard() {
  const board = document.getElementById("board");
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      board.children[r].children[c].textContent = grid[r][c];
    }
  }
}

function handleKeyPress(key) {
  if (!usernameSet || isAnimating) {
    return;
  }
  
  const msgEl = document.getElementById("message");
  if (msgEl.textContent.trim() === "You win! ðŸŽ‰" || msgEl.textContent.trim().startsWith("Game over!")) return;

  const keyButton = document.querySelector(`.key[data-key="${key.toUpperCase()}"]`);
  if (keyButton) {
    keyButton.classList.add("key-pop");
    setTimeout(() => {
      keyButton.classList.remove("key-pop");
    }, 100);
  }

  if (/^[a-zA-ZÃ„Ã–ÃœÃ¤Ã¶Ã¼ÃŸáºžÃ†Ã˜Ã…Ã¦Ã¸Ã¥]$/.test(key) && currentCol < cols) {
    let letter = key;
    if (key === "ÃŸ") letter = "áºž";
    else letter = key.toUpperCase();

    grid[currentRow][currentCol] = letter;
    currentCol++;
    updateBoard();
  } else if (key === "Backspace" && currentCol > 0) {
    currentCol--; grid[currentRow][currentCol] = ""; updateBoard();
  } else if (key === "Enter" && currentCol === cols) {
    submitGuess();
  }
}

window.addEventListener("keydown", (e) => {
  if (!usernameSet || isAnimating) return;
  
  if (document.getElementById("game").style.display !== "flex") return;
  const key = e.key.toUpperCase();
  if (key === "BACKSPACE") {
    handleKeyPress("Backspace");
  } else if (key === "ENTER") {
    handleKeyPress("Enter");
  } else if (/^[A-ZÃ„Ã–ÃœÃŸáºžÃ†Ã˜Ã…]$/.test(key)) {
    const keyToPass = key === 'ÃŸ' ? 'áºž' : key;
    handleKeyPress(keyToPass);
  }
});

function validateHardMode(guess) {
  for (let i = 0; i < guessHistory.length; i++) {
    const prevGuess = guessHistory[i];
    const colors = colorHistory[i];
    
    for (let j = 0; j < cols; j++) {
      if (colors[j] === "correct" && guess[j] !== prevGuess[j]) {
        document.getElementById("message").textContent = `Hard mode violation: Letter '${prevGuess[j]}' must be in position ${j+1}`;
        return false;
      }
    }

    const presentLetters = {};
    for (let j = 0; j < cols; j++) {
      if (colors[j] === "present") {
        presentLetters[prevGuess[j]] = (presentLetters[prevGuess[j]] || 0) + 1;
      }
    }
    for (const letter in presentLetters) {
      const countInGuess = [...guess].filter(l => l === letter).length;
      if (countInGuess < presentLetters[letter]) {
        document.getElementById("message").textContent = `Hard mode violation: Guess must include letter '${letter}' at least ${presentLetters[letter]} time(s)`;
        return false;
      }
    }

    for (let j = 0; j < cols; j++) {
      if (colors[j] === "absent") {
        const absentLetter = prevGuess[j];
        const isElsewherePresentOrCorrect = colors.some((color, idx) => 
          (color === "correct" || color === "present") && prevGuess[idx] === absentLetter);
        if (!isElsewherePresentOrCorrect) {
          if (guess.includes(absentLetter)) {
            document.getElementById("message").textContent = `Hard mode violation: Letter '${absentLetter}' cannot be used`;
            return false;
          }
        }
      }
    }
  }
  document.getElementById("message").textContent = "";
  return true;
}

async function loadAllWordLists() {
  console.log("Loading all word lists...");

  // Create an array of fetch promises
  const promises = SUPPORTED_LANGUAGES.map(lang => {
    const filePath = `${lang}.txt`; // e.g., "german.txt"
    return fetch(filePath)
      .then(response => {
        if (!response.ok) {
          throw new Error(`Failed to fetch ${filePath}`);
        }
        return response.text();
      });
  });

  try {
    // Wait for all files to be fetched and returned as an array of text content
    const allTexts = await Promise.all(promises);

    // Process each text file's content
    allTexts.forEach(text => {
      const words = text.split(/\s+/); // Splits by any whitespace
      words.forEach(word => {
        if (word) { // Ensure we don't add empty strings
          allValidWords.add(word.trim().toLowerCase());
        }
      });
    });

    console.log(`All word lists loaded! Total valid words: ${allValidWords.size}`);

  } catch (error) {
    console.error("Could not load one or more word lists:", error);
    // Handle the error, maybe show a message to the user
  }
}

function isValidWord(word) {
  // The check is now a simple, fast lookup in the Set.
  // We convert the guessed word to lowercase to ensure case-insensitivity.
  return allValidWords.has(word.toLowerCase());
}

async function submitGuess() {
  const guess = grid[currentRow].join("");
  if (guess.length !== cols) {
    const currentRowDiv = document.getElementById("board").children[currentRow];
    if (currentRowDiv) {
      currentRowDiv.classList.add("shake");
      setTimeout(() => {
        currentRowDiv.classList.remove("shake");
      }, 500);
    }
    document.getElementById("message").textContent = "Not enough letters";
    return;
  }

  if (!validateHardMode(guess)) {
    const currentRowDiv = document.getElementById("board").children[currentRow];
    if (currentRowDiv) {
      currentRowDiv.classList.add("shake");
      setTimeout(() => {
        currentRowDiv.classList.remove("shake");
      }, 500);
    }
    return;
  }

  // Check if the guess is in our loaded word lists. This is now instant.
  if (!isValidWord(guess)) {
    const currentRowDiv = document.getElementById("board").children[currentRow];
    if (currentRowDiv) {
      currentRowDiv.classList.add("shake");
      setTimeout(() => {
        currentRowDiv.classList.remove("shake");
      }, 500);
    }
    document.getElementById("message").textContent = "Not in word list";
    return;
  }

  // Word is valid, proceed with game logic and animations
  isAnimating = true; // Lock input during the animation
  document.getElementById("message").textContent = ""; // Clear any previous messages

  guessHistory.push(guess);
  const colors = Array(cols).fill("absent");
  const secretLetters = secret.split("");
  for (let i = 0; i < cols; i++) {
    if (guess[i] === secret[i]) {
      colors[i] = "correct";
      secretLetters[i] = null;
    }
  }
  for (let i = 0; i < cols; i++) {
    if (colors[i] === "correct") continue;
    const index = secretLetters.indexOf(guess[i]);
    if (index !== -1) {
      colors[i] = "present";
      secretLetters[index] = null;
    }
  }
  for (let i = 0; i < cols; i++) {
    const letter = guess[i];
    const color = colors[i];
    if (!keyColors[letter] || (color === "correct") || (color === "present" && keyColors[letter] === "absent")) {
      keyColors[letter] = color;
    }
  }

  updateKeyboardColors();

  colorHistory.push(colors);
  const board = document.getElementById("board");
  for (let i = 0; i < cols; i++) {
    const tile = board.children[currentRow].children[i];
    setTimeout(() => {
      tile.classList.add(colors[i]);
    }, i * 200);
  }

  setTimeout(() => {
    if (guess === secret) {
      endGame(true);
    } else if (currentRow === rows - 1) {
      endGame(false);
    } else {
      currentRow++;
      currentCol = 0;
      isAnimating = false; // Unlock input for the next row
      saveOngoingGame(window.currentUsername, base64Encode(secret));
    }
  }, cols * 200);
}

function endGame(won) {
    isAnimating = true; 
    const username = window.currentUsername;
    updateStats(username, won, currentRow + 1);

    const allGameData = JSON.parse(localStorage.getItem("gerNordleGameData") || "{}");
    const encodedSecret = base64Encode(secret);
    if (!allGameData[username]) {
        allGameData[username] = {};
    }

    // âœ… Preserve original creation date if it exists
    const existingGame = allGameData[username][encodedSecret];
    const creationDateToSave = existingGame && existingGame.createdDate
        ? existingGame.createdDate
        : (gameCreatedDate ? gameCreatedDate.toISOString() : new Date().toISOString());

    // Save game data
    if (allGameData[username][encodedSecret]) {
        delete allGameData[username][encodedSecret].ongoingState;
    }
    allGameData[username][encodedSecret] = {
        status: won ? 'won' : 'lost',
        guessHistory: guessHistory,
        colorHistory: colorHistory,
        hintStatus: { 
            hintUsed1, hintUsed2, hintUsed3, hintUsed4, 
            hintExpanded1, hintExpanded2, hintExpanded3, hintExpanded4 
        },
        createdDate: creationDateToSave
    };

    localStorage.setItem("gerNordleGameData", JSON.stringify(allGameData));

    // NEW: Save the score to Firebase
    const resultData = {
        username: window.currentUsername || "Anonymous",
        guesses: won ? currentRow + 1 : -1, // -1 or another indicator for a loss
        timestamp: new Date().toISOString()
    };
    saveScoreToFirebase(resultData);

    const modal = document.getElementById("game-over-modal");

    // Message
    if (won) {
        document.getElementById("modal-message").innerHTML = 
            `You win! ðŸŽ‰<br>The secret word was <span id="secretWordColor">${secret}</span>.`;
    } else {
        document.getElementById("modal-message").innerHTML = 
            `Game over!<br>The secret word was <span id="secretWordColor">${secret}</span>.`;
    }

    // Summary text
    const hintStatusForSummary = { hintUsed1, hintUsed2, hintUsed3, hintUsed4 };
    document.getElementById("modal-summary").textContent = 
        generateResultText(true, guessHistory, colorHistory, won, hintStatusForSummary);

    // Remove existing fun fact if present
    const existingFunFact = document.querySelector("#game-over-modal .fun-fact-section");
    if (existingFunFact) existingFunFact.remove();

    // Add fun fact if available
    if (customFunFact && customFunFact.trim() !== "") {
        const funFactDiv = document.createElement('div');
        funFactDiv.classList.add('fun-fact-section');
        const funFactHeader = document.createElement('h2');
        funFactHeader.textContent = "Fun fact about today's WÃ¸rtle:";
        const funFactText = document.createElement('p');
        funFactText.textContent = customFunFact;
        funFactText.style.margin = "0";
        funFactDiv.appendChild(funFactHeader);
        funFactDiv.appendChild(funFactText);
        document.querySelector("#game-over-modal .modal-content").appendChild(funFactDiv);
    }

    // Stats section
    const statsContainer = document.getElementById("modal-stats-container");
    statsContainer.innerHTML = "";
    statsContainer.classList.remove('expanded');
    document.getElementById('showStatsBtn').textContent = "Show My Stats";

    displayStats(username).forEach(line => {
        const p = document.createElement('p');
        p.textContent = line;
        p.classList.add('stats-line'); // âœ… Added class for styling
        statsContainer.appendChild(p);
    });

    // Bind modal buttons (copy + toggle stats)
    bindModalButtons(guessHistory, colorHistory, won, hintStatusForSummary);

    // Hide the game board to remove the scroll space
    document.getElementById("game").style.display = "none";

    // Show modal
    document.getElementById("game-over-overlay").classList.add('show');
    document.getElementById("modalCopyBtn").style.display = "block";
}

function getPlayerId() {
  let playerId = localStorage.getItem('myWordlePlayerId');
  if (!playerId) {
    // Create a simple, random ID if one doesn't exist
    playerId = 'player_' + Date.now() + Math.random().toString(36).substring(2, 9);
    localStorage.setItem('myWordlePlayerId', playerId);
  }
  return playerId;
}

function saveScoreToFirebase(resultData) {
  if (!secret || !window.currentUsername) return;
  const playerId = getPlayerId(); // e.g., 'player_12345'
  const username = window.currentUsername; // e.g., 'PLAYER1'
  // Create a composite key from both the username and the player ID.
  // We encode the username to make sure it's a valid key in Firebase.
  const compositeKey = `${encodeURIComponent(username)}_${playerId}`;
  // --- NEW: Calculate hint count ---
  let hintCount = 0;
  if (hintUsed1) hintCount++;
  if (hintUsed2) hintCount++;
  if (hintUsed3) hintCount++;
  if (hintUsed4) hintCount++;
  
  // Add hintCount to the data being saved
  resultData.hintCount = hintCount;
  // Create a "game room" using the secret word
  const gameRef = database.ref('games/' + secret);
  // Use the new composite key to save the score
  const userScoreRef = gameRef.child(compositeKey);
  userScoreRef.set(resultData);
}

function initBoard() {
  const board = document.getElementById("board");
  board.innerHTML = "";
  for (let r = 0; r < rows; r++) {
    const rowDiv = document.createElement("div");
    rowDiv.classList.add("row");
    for (let c = 0; c < cols; c++) {
      const tileDiv = document.createElement("div");
      tileDiv.classList.add("tile");
      rowDiv.appendChild(tileDiv);
    }
    board.appendChild(rowDiv);
  }
}

function initKeyboard() {
  const keyboardDiv = document.getElementById("keyboard");
  keyboardDiv.innerHTML = "";
  const keysLayout = [
    ["Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P", "Ã…"],
    ["A", "S", "D", "F", "G", "H", "J", "K", "L", "Ã–", "Ã„", "Ã˜"],
    ["Enter", "Z", "X", "C", "V", "B", "N", "M", "Ãœ", "áºž", "Ã†", "Backspace"]
  ];

  keysLayout.forEach(row => {
    const rowDiv = document.createElement("div");
    rowDiv.classList.add("key-row");
    row.forEach(key => {
      const keyBtn = document.createElement("button");
      keyBtn.textContent = key;
      keyBtn.classList.add("key");
      keyBtn.dataset.key = key;
      keyBtn.onclick = () => handleKeyPress(key);
      rowDiv.appendChild(keyBtn);
    });
    keyboardDiv.appendChild(rowDiv);
  });
}

function updateKeyboardColors() {
    for (const key in keyColors) {
        const keyBtn = document.querySelector(`.key[data-key="${key}"]`);
        if (keyBtn) {
            keyBtn.classList.remove("present", "absent", "correct"); // Clear old colors
            keyBtn.classList.add(keyColors[key]);
        }
    }
}

function showHint(hintNumber) {
    let btn, hintText, hintContent;
    
    switch(hintNumber) {
        case 1:
            btn = document.getElementById('hintBtn1');
            hintContent = customHint1;
            if (hintUsed1) return; 
            hintUsed1 = true; 
            hintExpanded1 = true;
            break;
        case 2:
            btn = document.getElementById('hintBtn2');
            hintContent = customHint2;
            if (hintUsed2) return; 
            hintUsed2 = true; 
            hintExpanded2 = true;
            break;
        case 3:
            btn = document.getElementById('hintBtn3');
            hintContent = customHint3;
            if (hintUsed3) return; 
            hintUsed3 = true; 
            hintExpanded3 = true;
            break;
        case 4:
            btn = document.getElementById('hintBtn4');
            hintContent = customHint4;
            if (hintUsed4) return; 
            hintUsed4 = true; 
            hintExpanded4 = true;
            break;
    }

    if (btn && !btn.classList.contains('expanded')) {
        hintText = btn.querySelector('.hint-text');
        hintText.textContent = hintContent;
        btn.classList.add('expanded');
        hintText.classList.add('visible');
        btn.classList.add('clicked-hint');
        btn.disabled = true;
    }
    
    // âœ… Add this line to save the game state immediately
    if (window.currentUsername && secret) {
        saveOngoingGame(window.currentUsername, base64Encode(secret));
    }
}

function generateResultText(isForDisplay, history, colors, won, hintStatus) {
    // Get and format the current date
    const dateToUse = gameCreatedDate || new Date();
    const options = { year: 'numeric', month: 'short', day: 'numeric' };
    const dateString = dateToUse.toLocaleDateString('en-GB', options);

    // The first line of the result text
    let text = `WÃ˜RTLE (${won ? history.length : 'X'}/6)\n`;
    
    // Add the formatted date on the next line
    text += `${dateString}\n`;

    // Count the total number of hints used
    let hintCount = 0;
    if (hintStatus.hintUsed1) hintCount++;
    if (hintStatus.hintUsed2) hintCount++;
    if (hintStatus.hintUsed3) hintCount++;
    if (hintStatus.hintUsed4) hintCount++;

    // Add the emoji grid (this part remains the same)
    const colorMap = {
        correct: 'ðŸŸ©',
        present: 'ðŸŸ¨',
        absent: 'â¬›'
    };

    for (let i = 0; i < colors.length; i++) {
        let rowText = colors[i].map(color => colorMap[color] || 'â¬›').join('');
        text += rowText + '\n';
    }

    // Add the hint summary sentence if any hints were used, followed by a blank line
    if (hintCount === 1) {
        text += "1 hint used\n";
    } else if (hintCount > 1) {
        text += `${hintCount} hints used\n`;
    } else {
        // If no hints were used, just add a blank line for spacing
        text += "\n";
    }

    return text;
}

function resetHints() {
    hintUsed1 = hintUsed2 = hintUsed3 = hintUsed4 = false;
    hintExpanded1 = hintExpanded2 = hintExpanded3 = hintExpanded4 = false; // Reset new variables
    ['hintBtn1', 'hintBtn2', 'hintBtn3', 'hintBtn4'].forEach(id => {
        const btn = document.getElementById(id);
        if (btn) {
            btn.classList.remove('expanded', 'clicked-hint');
            btn.disabled = false;
            const hintTextSpan = btn.querySelector('.hint-text');
            if(hintTextSpan) {
              hintTextSpan.classList.remove('visible');
              hintTextSpan.textContent = '';
            }
            const hintLabel = btn.querySelector('.hint-label');
            if (hintLabel) {
                hintLabel.classList.remove('hidden');
            }
        }
    });
}

// Initial setup on page load
window.onload = () => {
  secret = getSecretFromURL();
  const headerInfo = document.getElementById("header-info");
  if (secret) {
    headerInfo.style.display = "flex";
    document.getElementById("setup").style.display = "none";
    document.getElementById("game").style.display = "flex";
    checkUserStatus();
  } else {
    // This is the HOST page, so hide the header
    headerInfo.style.display = "none";
    
    // --- ADD THIS NEW LOGIC ---
    // 1. Load any previously saved form data
    loadSetupState();
    
    // 2. Set up event listeners to save data on any change
    const setupInputs = [
      document.getElementById('secretInput'),
      document.getElementById('hintInput'),
      document.getElementById('hintInput2'),
      document.getElementById('hintInput3'),
      document.getElementById('funFactInput')
    ];
    setupInputs.forEach(input => input.addEventListener('input', saveSetupState));
    document.querySelectorAll('.specialCharCheckbox').forEach(cb => cb.addEventListener('change', saveSetupState));
    // --- END OF NEW LOGIC ---
  }
};

function saveOngoingGame(username, encodedSecret) {
    if (!username || !encodedSecret) return;

    // Get the main data object from localStorage
    const allGameData = JSON.parse(localStorage.getItem("gerNordleGameData") || "{}");

    // Ensure the structure for the user and secret exists
    if (!allGameData[username]) {
        allGameData[username] = {};
    }
    if (!allGameData[username][encodedSecret]) {
        allGameData[username][encodedSecret] = {};
    }

    // Create an object with all the data needed to restore the game
    const ongoingState = {
        grid,
        currentRow,
        guessHistory,
        colorHistory,
        keyColors,
        hintStatus: { hintUsed1, hintUsed2, hintUsed3, hintUsed4, hintExpanded1, hintExpanded2, hintExpanded3, hintExpanded4 }
    };

    // Save this state to the specific user and word
    allGameData[username][encodedSecret].ongoingState = ongoingState;

    // Write the updated data back to localStorage
    localStorage.setItem("gerNordleGameData", JSON.stringify(allGameData));
}

function setupHeader(username) {
    const usernameDisplayArea = document.getElementById("username-display-area");
    const topStatsDisplay = document.getElementById("topStatsDisplay");
    const changeUserButtonArea = document.getElementById("change-user-button-area");

    // Display the username
    const displayMessage = document.createElement("p");
    displayMessage.textContent = `Playing as: ${username.toUpperCase()}`;
    displayMessage.style.cssText = "margin: 0;";
    usernameDisplayArea.appendChild(displayMessage);

    // Display the "Change User" button
    const changeButton = document.createElement("button");
    changeButton.textContent = "Change User";
    changeButton.onclick = promptForUsername;
    changeButton.classList.add("styled-button");
    changeUserButtonArea.appendChild(changeButton);

    // Display the user's stats
    const stats = getStats(username);
    let avgGuesses = stats.wins > 0 ? (stats.totalGuesses / stats.wins).toFixed(2) : "-";
    let winPct = stats.gamesPlayed > 0 ? ((stats.wins / stats.gamesPlayed) * 100).toFixed(1) : "0.0";
    topStatsDisplay.innerHTML = `Games Played: ${stats.gamesPlayed} | Win %: ${winPct}% | Avg. Guesses: ${avgGuesses}`;
    topStatsDisplay.style.display = "block";
}

const helpBtn = document.getElementById("helpBtn");
const helpPopup = document.getElementById("helpPopup");
const closeHelpBtn = document.getElementById("closeHelpBtn");
const helpOverlay = document.getElementById("helpOverlay");
const mainContent = document.getElementById("mainContent");

function showHelpPopup() {
  helpPopup.hidden = false;
  helpOverlay.hidden = false;
  mainContent.inert = true;
  mainContent.setAttribute('aria-hidden', 'true');
  setInputsDisabled(true);
  helpPopup.focus();
}

function hideHelpPopup() {
  helpPopup.hidden = true;
  helpOverlay.hidden = true;
  mainContent.inert = false;
  mainContent.removeAttribute('aria-hidden');
  setInputsDisabled(false);
}

// Find the new button in the document
const newGameBtn = document.getElementById("newGameBtn");

// This function navigates to the base URL of your site
function goToHostPage() {
  // window.location.origin provides the base URL (e.g., "https://your-site.com")
  window.location.href = window.location.origin + window.location.pathname;
}

// Attach the function to the button's click event
if (newGameBtn) {
  newGameBtn.addEventListener("click", goToHostPage);
}

helpBtn.addEventListener("click", (e) => {
  e.stopPropagation();
  if (helpPopup.hidden) {
    showHelpPopup();
  } else {
    hideHelpPopup();
  }
});

closeHelpBtn.addEventListener("click", () => {
  hideHelpPopup();
});

helpOverlay.addEventListener("click", () => {
  hideHelpPopup();
});

// Global keydown: block all keys except Ctrl/Meta shortcuts and Escape when popup is visible
document.addEventListener("keydown", (event) => {
  if (!helpPopup.hidden) {
    // Allow Escape to close popup
    if (event.key === "Escape") {
      return;
    }

    // For Cmd/Ctrl + key combos like Cmd+C:
    if (event.ctrlKey || event.metaKey) {
      // Stop propagation to prevent Wordle input, but allow native shortcut
      event.stopImmediatePropagation();
      // Don't preventDefault here so native shortcut works
      return;
    }

    // Block all other keys completely (typing)
    event.preventDefault();
    event.stopImmediatePropagation();
  }
}, true);

// Also block typing on Wordle input elements specifically except shortcuts and Escape
const wordleInputs = mainContent.querySelectorAll('input, textarea, [contenteditable="true"]');
wordleInputs.forEach(input => {
  input.addEventListener('keydown', (event) => {
    if (!helpPopup.hidden) {
      if (event.ctrlKey || event.metaKey || event.key === "Escape") {
        return; // allow shortcuts and Escape
      }
      event.preventDefault();
      event.stopImmediatePropagation();
    }
  }, true);
});

// Optional: allow Escape to close popup (already handled above, but keep if needed)
document.addEventListener("keydown", (event) => {
  if (!helpPopup.hidden && event.key === "Escape") {
    hideHelpPopup();
  }
});

// Prevent clicks inside popup from closing it
helpPopup.addEventListener("click", (event) => {
  event.stopPropagation();
});

function setInputsDisabled(state) {
  // Select all inputs, textareas, and contenteditable elements inside mainContent
  const inputs = mainContent.querySelectorAll('input, textarea, [contenteditable="true"], button, select');
  inputs.forEach(el => {
    el.disabled = state;
    if (state) {
      el.setAttribute('aria-disabled', 'true');
      el.blur(); // remove focus when disabling
    } else {
      el.removeAttribute('aria-disabled');
    }
  });
}
function updateHintButtons() {
    const hintBtn1 = document.getElementById("hintBtn1");
    const hintBtn2 = document.getElementById("hintBtn2");
    const hintBtn3 = document.getElementById("hintBtn3");
    const hintBtn4 = document.getElementById("hintBtn4");

    // Hide all hint buttons by default.
    hintBtn1.style.display = "none";
    hintBtn2.style.display = "none";
    hintBtn3.style.display = "none";
    hintBtn4.style.display = "none";

    let hasAnyHints = false; // Track if any hints are available

    // Helper function to restore a single hint button's state
    function restoreHintButton(btn, hintContent, used, expanded) {
        if (hintContent && hintContent.trim() !== "") {
            hasAnyHints = true; // Mark that we have at least one hint

            // Show the button in the pop-up.
            btn.style.display = "inline-flex";

            if (used) {
                btn.classList.add('clicked-hint');
                btn.disabled = true;

                if (expanded) {
                    const hintTextSpan = btn.querySelector('.hint-text');
                    if (hintTextSpan) {
                        hintTextSpan.textContent = hintContent;
                        hintTextSpan.classList.add('visible');
                    }
                    btn.classList.add('expanded');
                    btn.querySelector('.hint-label').classList.add('hidden');
                }
            } else {
                btn.disabled = false;
                btn.classList.remove('clicked-hint', 'expanded');
                const hintTextSpan = btn.querySelector('.hint-text');
                if (hintTextSpan) {
                    hintTextSpan.classList.remove('visible');
                    hintTextSpan.textContent = ""; // Clear hidden hint text
                }
                btn.querySelector('.hint-label').classList.remove('hidden');
            }
        }
    }

    // Apply restoration logic for each hint button
    restoreHintButton(hintBtn1, customHint1, hintUsed1, hintExpanded1);
    restoreHintButton(hintBtn2, customHint2, hintUsed2, hintExpanded2);
    restoreHintButton(hintBtn3, customHint3, hintUsed3, hintExpanded3);
    restoreHintButton(hintBtn4, customHint4, hintUsed4, hintExpanded4);

    // Show or hide the "Need a hint?" container based on availability
    document.getElementById("hintButtons").style.display = hasAnyHints ? "block" : "none";
}

function bindModalButtons(savedGuessHistory, savedColorHistory, isSolved, savedHintStatus) {
    const modalCopyBtn = document.getElementById("modalCopyBtn");
    const showStatsBtn = document.getElementById("showStatsBtn");
    const showScoreboardBtn = document.getElementById("showScoreboardBtn");

    // --- 1. Copy Result Button ---
    if (modalCopyBtn) {
        modalCopyBtn.onclick = () => {
            const resultText = generateResultText(false, savedGuessHistory, savedColorHistory, isSolved, savedHintStatus);
            navigator.clipboard.writeText(resultText).then(() => {
                modalCopyBtn.innerHTML = "<i>Copied!</i>";
                modalCopyBtn.disabled = true;
                setTimeout(() => {
                    modalCopyBtn.innerHTML = "Copy Result";
                    modalCopyBtn.disabled = false;
                }, 1500);
            });
        };
    }

    // --- 2. Stats Toggle Button ---
    if (showStatsBtn) {
        showStatsBtn.onclick = () => {
            const statsContainer = document.getElementById("modal-stats-container");
            statsContainer.classList.toggle('expanded');
            showStatsBtn.textContent = statsContainer.classList.contains('expanded') ? "Hide My Stats" : "Show My Stats";
        };
    }

    // --- 3. View/Hide Scoreboard Button (MODIFIED) ---
    if (showScoreboardBtn) {
        // Set initial text
        showScoreboardBtn.textContent = "View Scoreboard";
        
        showScoreboardBtn.onclick = () => {
            const scoreboardPanel = document.getElementById('scoreboard-panel');
            // Check if the panel is already visible
            if (scoreboardPanel.classList.contains('show')) {
                hideScoreboard(); // If yes, hide it
            } else {
                showScoreboard(); // If no, show it
            }
        };
    }
}

function showHintPopup() {
  hintPopup.classList.add("show");
}

function hideHintPopup() {
  hintPopup.classList.remove("show");
}
// Event listeners for the hint popup
if (hintTitle) {
  hintTitle.addEventListener("click", showHintPopup);
}
if (closeHintPopupBtn) {
  closeHintPopupBtn.addEventListener("click", hideHintPopup);
}

// This handles the "click outside" functionality
if (hintPopupOverlay) {
  hintPopupOverlay.addEventListener("click", hideHintPopup);
}

// This prevents clicks *inside* the popup from closing it
if (hintPopup) {
  hintPopup.addEventListener("click", (event) => {
    event.stopPropagation();
  });
}
// --- Add this new function to your script ---

function generateRandomWord() {
  // Ensure the word list has been loaded
  if (allValidWords.size === 0) {
    alert("Word lists are still loading. Please wait a moment and try again.");
    return;
  }

  // Convert the Set of words into an array to easily pick a random one
  const allWordsArray = [...allValidWords];
  
  // Select a random word from the array
  const randomIndex = Math.floor(Math.random() * allWordsArray.length);
  const randomWord = allWordsArray[randomIndex];

  // Put the selected word into the input field, in uppercase
  const secretInput = document.getElementById("secretInput");
  secretInput.value = randomWord.toUpperCase();
}

// --- Add this event listener to make the button work ---

// Find the new button in the document
const generateBtn = document.getElementById("generateWordBtn");

// Attach the function to the button's click event
if (generateBtn) {
  generateBtn.addEventListener("click", generateRandomWord);
}

// --- Find the new scoreboard elements ---
const scoreboardPanel = document.getElementById('scoreboard-panel');

function showScoreboard() {
  const showScoreboardBtn = document.getElementById('showScoreboardBtn');
  // First, fetch the data and populate the panel
  fetchAndDisplayScoreboard();
  // Then, slide the panel into view
  scoreboardPanel.classList.add('show');
  // Update button text
  if (showScoreboardBtn) {
    showScoreboardBtn.textContent = 'Hide Scoreboard';
  }
}

// This function now hides the side panel
function hideScoreboard() {
  const showScoreboardBtn = document.getElementById('showScoreboardBtn');
  scoreboardPanel.classList.remove('show');
  
  // Reset the button text
  if (showScoreboardBtn) {
    showScoreboardBtn.textContent = 'View Scoreboard';
  }
  
  // Clean up the real-time listener to prevent memory leaks
  if (scoreboardListener && secret) {
      const gameRef = database.ref('games/' + secret);
      gameRef.off('value', scoreboardListener);
      scoreboardListener = null; // Clear the variable
  }
}

function fetchAndDisplayScoreboard() {
    if (!secret) return;

    const container = document.getElementById('scoreboard-container');
    const wordDisplay = document.getElementById('scoreboard-word');
    // Get the new summary container
    const summaryContainer = document.getElementById('scoreboard-summary-container');
    
    if (!container || !wordDisplay || !summaryContainer) {
        console.error("Scoreboard HTML elements not found! Check your element IDs.");
        return; 
    }

    const gameRef = database.ref('games/' + secret);

    wordDisplay.textContent = secret;
    container.innerHTML = '<p>Loading scores...</p>';
    summaryContainer.innerHTML = ''; // Clear previous summary

    if (scoreboardListener) {
        gameRef.off('value', scoreboardListener);
    }
    
    scoreboardListener = gameRef.on('value', (snapshot) => {
        const scores = snapshot.val();

        if (!scores) {
            container.innerHTML = '<p>Be the first to set a score!</p>';
            return;
        }

        const allScores = Object.values(scores || {});

        // ---- NEW: Calculate Average Stats ----
        const totalPlayers = allScores.length;
        const winners = allScores.filter(score => score.guesses > 0);
        const totalWinners = winners.length;

        const solveRate = totalPlayers > 0 ? (totalWinners / totalPlayers) * 100 : 0;
        
        const totalGuesses = winners.reduce((sum, player) => sum + player.guesses, 0);
        const avgGuesses = totalWinners > 0 ? totalGuesses / totalWinners : 0;

        const totalHints = allScores.reduce((sum, player) => sum + (player.hintCount || 0), 0);
        const avgHints = totalPlayers > 0 ? totalHints / totalPlayers : 0;

        // Generate HTML for the summary section
        summaryContainer.innerHTML = `
            <div class="summary-stat">
                <span class="stat-label">Solve Rate</span>
                <div class="stat-bar-container">
                    <div class="stat-bar" style="width: ${solveRate.toFixed(1)}%;">${solveRate.toFixed(1)}%</div>
                </div>
            </div>
            <div class="summary-stat">
                <span class="stat-label">Avg. Guesses</span>
                <div class="stat-bar-container">
                    <div class="stat-bar" style="width: ${(avgGuesses / 6) * 100}%;">${avgGuesses.toFixed(1)}</div>
                </div>
            </div>
            <div class="summary-stat">
                <span class="stat-label">Avg. Hints</span>
                <div class="stat-bar-container">
                    <div class="stat-bar" style="width: ${(avgHints / 4) * 100}%;">${avgHints.toFixed(1)}</div>
                </div>
            </div>
        `;
        // ---- END OF NEW STATS LOGIC ----


        // Sort players for the main scoreboard table
        winners.sort((a, b) => {
            const guessDifference = a.guesses - b.guesses;
            if (guessDifference !== 0) return guessDifference;
            return (a.hintCount || 0) - (b.hintCount || 0);
        });

        const losers = allScores.filter(score => score.guesses <= 0);
        const sortedScores = [...winners, ...losers];

        if (sortedScores.length === 0) {
            container.innerHTML = '<p>No scores have been recorded yet.</p>';
            return;
        }

        let tableHTML = `
            <table>
                <thead><tr><th>Rank</th><th>Player</th><th>Guesses</th><th>Hints</th></tr></thead>
                <tbody>`;

        sortedScores.forEach((score, index) => {
            const guessDisplay = score.guesses > 0 ? score.guesses : 'X';
            tableHTML += `
                <tr>
                    <td>${index + 1}</td>
                    <td>${score.username}</td>
                    <td>${guessDisplay}</td>
                    <td>${score.hintCount || 0}</td>
                </tr>`;
        });

        tableHTML += '</tbody></table>';
        container.innerHTML = tableHTML;

    }, (error) => {
        console.error("Firebase listener error:", error);
        container.innerHTML = '<p>Could not load scores due to an error.</p>';
        summaryContainer.innerHTML = '<p style="text-align:center; color:#c7d1d5;">Could not load stats.</p>';
    });
}


</script>
</body>
</html>
